# 딕셔너리에서 값을 찾는것이 배열에 비해서 왜 빠를까요?

딕셔너리와 배열은 서로 다른 자료구조로 구현되어 있어요.

딕셔너리는 해시 테이블이라는 자료 구조를 기반으로 해요. 이 구조는 키를 특정 값을 가지는 해시로 변환하고, 이 해시를 사용하여 값을 빠르게 찾을 수 있게 해요. 해시 함수는 대부분의 경우에서 일정한 시간 안에 결과를 반환하므로, 딕셔너리에서 값을 검색하는 시간 복잡도는 평균적으로 O(1)이에요.

배열은 순차적인 데이터 구조이므로, 특정 값을 찾기 위해서는 처음부터 끝까지 순차적으로 검색해야 할 수도 있어요. 따라서 배열에서의 검색은 최악의 경우 O(n)의 시간 복잡도를 가져요.

물론, 딕셔너리의 해시 충돌이 발생할 경우 이러한 이점이 상대적으로 감소할 수 있어요. 그러나 현대의 딕셔너리 구현체는 충돌을 최소화하는 효율적인 해싱 알고리즘을 사용하기 때문에, 대부분의 경우에서 딕셔너리의 검색 속도는 매우 빨라요.

## 해시 알고리즘 종류

**MD5 (Message Digest Algorithm 5)**

원래 메시지 무결성 검사를 위해 설계되었습니다.
128비트 해시 값을 생성합니다.
오늘날에는 알려진 취약점이 있어서 보안 목적으로 사용되는 것은 권장되지 않습니다.

**SHA-1 (Secure Hash Algorithm 1)**

NSA에 의해 설계되었으며, DSA 디지털 서명 알고리즘의 일부로 초기에 사용되었습니다.
160비트 해시 값을 생성합니다.
마찬가지로 알려진 취약점 때문에 보안 목적으로 사용되는 것은 권장되지 않습니다.

**SHA-256, SHA-384, SHA-512 (SHA-2 패밀리)**

SHA-1의 뒤를 이어서 NSA에 의해 개발되었습니다.
각각 256비트, 384비트, 512비트 해시 값을 생성합니다.
현재는 많은 보안 시스템에서 널리 사용됩니다.

**SHA-3**

SHA-2와는 다른 구조를 가지며, 2015년에 NIST에 의해 표준화되었습니다.
다양한 길이의 해시 값을 생성할 수 있습니다.

**bcrypt & scrypt**

암호 저장에 특화된 해시 알고리즘입니다.
입력된 암호에 소금을 추가하고 여러 번 해싱하는 방식으로, 무차별 대입 공격에 대한 저항성을 높입니다.

**Murmur & CityHash**

빠른 성능을 목표로 개발된 비암호화 해시 알고리즘입니다.
주로 해시 테이블이나 캐시에 사용됩니다.

## 궁금했던 점

해시 알고리즘은 랜덤 함수가 아니라 결정론적이다.

즉 같은 입력에 대해 매번 같은 결과를 반환한다는 것. 그렇다면 내가 원하는 순서는 보장하지 못할지라도 특정한 순서를 항상 보장해야하는 것 아닌가???

당연히도 아니었다.

swift에서 사용하는 해시 함수는 [Hasher](https://developer.apple.com/documentation/swift/hasher) 인데 문서를 읽어보면 무작위 시드를 사용하여 실행할 때마다 다른 값이 반환된다고 한다.

그렇다면 한번 실행된 상태에서는 항상 동일한 순서를 반환할까?

이것도 테스트해본 결과 딕셔너리에 값을 추가하거나 삭제하면 순서가 바뀌고 그냥 읽기만 하면 순서가 바뀌지 않는 것을 확인할 수 있었다.

한 가지 신기했던 점은 값을 추가하거나 삭제할 때 순서가 아예 랜덤인 것 같다는 것이다. 한 번 프로그램이 실행 될 때 랜덤 시드가 적용되고, 이후에 값을 추가하게 된다면 기존의 순서는 유지된 상태에서 랜덤 번째에 값이 추가되는 것이 아니라는게 신기했다.
