# 오류 처리 구문

초기에 발표된 스위프트는 옵셔너을 통해 오류를 충분히 처리할 수 있어서, 타 언어에서 즐겨 사용되는 try~catch와 같은 오류 처리 구문이 필요하지 않을 만큼 안정성이 뛰어나다는 점을 강점으로 내세웠어요.

하지만 이 부분에는 단점이 있었는데, 오류가 발생했을 때 오류에 대한 정보를 외부로 전달할 방법이 없다는 점이에요.

예를 들어, 문자열을 입력받고 이를 정수로 변환한 후 반환하는 기능을 하는 함수가 정의되어 있다고 가정해보죠. 이 함수는 입력받은 문자열인자값에 따라 여러 가지 오류 상황을 내포하고 있어요. 인자값에 nil 값이 입력될 수도 있고, 정수로 변환할 수 없는 일반 문자열이나 특수 문자가 입력될 수도 있어요.

이런 다양한 오류 상황이 있음에도 불구하고 이 함수가 표현할 수 있는 오류는 단순히 nil 하나에요. 서로 다른 오류가 발생했음에도 불구하고 이를 자세하게 함수 외부로 전달하기 곤란할 뿐만 아니라, 함수를 호출한 외부 코드에서도 함수 내부에서 발생한 오류에 대해 자세한 정보를 받을 수 없는 것이죠.

이런 문제점 외에도 코코아터치 프레임워크에서 사용하는 오류 처리 구조 역시 스위프트가 본래 바라던 아키텍처와 차이가 있어요. 오브젝티브-C 기반으로 작성된 코코아터치 프레임워크에서 오류 정보를 반환하는 방식은 오류 정보를 저장할 객체를 인자값으로 함수나 메소드에 전달한 다음 필요할 때 꺼내어 사용하는 방식이에요.

이는 함수나 메소드에서 반환 타입을 준수하면서도 오류 정보를 제공할 수 있는 방법이지만, 기본적으로 오류에 대한 모든 대응을 옵셔널 타입으로 해결하고자 하는 스위프트의 언어 구조 입장에서 그다지 좋은 선택은 아니에요.

최근의 객체지향 언어들은 오류가 발생했을 때 함수나 메소드에서 해당 오류를 '반환(returns)'하는 것이 아니라 '던지는(throws)' 처리를 할 수 있게끔 지원해요.

스위프트에서도 결국 2 버전을 발표하면서 이러한 오류 처리 구문을 도입했어요. 이 때문에 코코아터치 프레임워크에서도 일부 변화가 있었어요. 오브젝티브-C 방식처럼 오류 객체를 인자값으로 넣어 호출하던 메소드나 함수 대신 오류를 던지기 시작한 것이죠. 우리는 메소드를 정의할 때 오류를 던지고, 이 메소드를 호출하여 사용할 때 오류를 잡아낼 수 있도록 구문을 작성해야 해요.

[이전](https://github.com/MojitoBar/iOS-DeepDive/blob/main/%EA%BC%BC%EA%BC%BC%ED%95%9C_%EC%9E%AC%EC%9D%80%EC%94%A8%EC%9D%98_Swift_%EB%AC%B8%EB%B2%95%ED%8E%B8/11.md)
[다음](https://github.com/MojitoBar/iOS-DeepDive/blob/main/%EA%BC%BC%EA%BC%BC%ED%95%9C_%EC%9E%AC%EC%9D%80%EC%94%A8%EC%9D%98_Swift_%EB%AC%B8%EB%B2%95%ED%8E%B8/11.1.md)

[처음으로](https://github.com/MojitoBar/iOS-DeepDive/blob/main/%EA%BC%BC%EA%BC%BC%ED%95%9C_%EC%9E%AC%EC%9D%80%EC%94%A8%EC%9D%98_Swift_%EB%AC%B8%EB%B2%95%ED%8E%B8/README.md)
