# 일급 함수의 특성

객체가 다음의 조건을 만족하는 경우 이 객체를 일급 객체로 간주해요.

- 객체가 런타임에도 생성이 가능해야 한다.
- 인자값으로 객체를 전달할 수 있어야 한다.
- 반환값으로 객체를 전달할 수 있어야 한다.
- 변수나 데이터 구조 안에 저장할 수 있어야 한다.
- 할당에 사용된 이름과 관계없이 고유한 구별이 가능해야 한다.

함수가 이러한 조건을 만족하면 이를 일급 함수라고 하고 그 언어를 함수형 언어로 분류해요. 즉, 함수형 언어에서는 함수가 일급 객체로 대우받는다는 뜻이에요.

지금부터 일급 함수의 특성애 대해 단계적으로 하나씩 살펴봐요.

### 일급 함수의 특성 - 변수나 상수에 함수를 대입할 수 있음.

```swift
func foo(base: Int) -> String {
    return "결과값은 \(base + 1)입니다."
}

let fn1 = foo(base: 5)
print(fn1) // 결과값은 6입니다.
```

변수나 상수에 함수를 대입할 수 있다고 설명했을 때 이런 구문을 떠올리는 분들이 많아요. 하지만 이 구문은 함수의 결과값을 fn1이라는 상수에 할당하는 단순한 대입 연산에 지나지 않아요.

일급 함수에서 말하는 **'변수나 상수에 함수를 대입한다.'**라는 의미는 이것과 달라요. 함수를 대입한 변수가 함수처럼 실행된다는 것은 우리가 학습한 함수 호출이 확장됨을 의미해요.

```swift
let fn2 = foo
fn2(5) // 결과값은 6입니다.
```

상수 fn2에 foo 함수를 대입하고 있어요. 함수 자체가 대입되었으므로 이제 fn2는 foo와 이름만 다를 뿐 같은 인자값, 같은 기능, 같은 반환값을 가지는 함수가 돼요. 그래서 fn2를 호출하면 foo 함수를 호출한 것과 같은 결과를 얻을 수 있어요.

함수를 대입하기 위해 알아야 할 것이 하나 더 있어요. 바로 **타입(Types)**이에요. 변수에 함수를 대입하면 그 변수는 일반적인 문자열, 정수, 배열 또는 딕셔너리와는 전혀 다른 타입이 돼요. 이 타입을 **함수 타입(Function Types)**이라고 해요.

함수 타입은 일반적으로 함수의 형태를 축약한 형태로 사용하는데, 이때 함수의 이름이나 실행 내용 등은 함수 타입에서는 아무런 의미가 없으므로 생략할 수 있어요.

```swift
func boo(age: Int) -> String {
    return "\(age)"
}
```

정수 인수를 받고 문자열 타입을 반환하는 boo(age:) 함수에요. 이 함수를 함수 타입 형태로 표현하면 다음과 같아요.

> (Int) -> String

해당 함수 타입으로 변수를 선언하면 다음과 같아요.

```swift
var fn3: (Int) -> String = boo
```

그런데, 우리가 지금 대입 구문에 사용한 boo라는 이름은 우리가 알고 있는 정확한 함수 식별자가 아니에요. 정확한 식별자는 boo(age: Int)죠. 그래서 위 구문은 다음과 같이 함수 식별자를 대입해주는 구문으로 바꾸어 작성할 수도 있어요.

```swift
var fn3: (Int) -> String = boo(age:)
```

그러면 함수의 이름도 아닌 것이 왜 함수의 대입 구문에 사용해도 아무런 문제가 없는 것일까요?

이는 스위프트의 타입 추론 덕분이에요. 스위프트는 타입 추론을 통해 변수나 상수의 타입을 추론할 수 있어요. 그래서 우리가 함수의 이름을 생략하고 대입 구문을 작성해도 스위프트가 알아서 함수의 이름을 찾아서 대입해줘요.

그런데, 만약 똑같은 함수의 이름을 가진 함수가 여러 개 있다면 어떻게 될까요? 이런 경우에는 함수의 이름을 생략하고 대입 구문을 작성하면 에러가 발생해요. 왜냐하면 스위프트가 어떤 함수를 대입해야 할지 모르기 때문이에요.

```swift
func boo(age: Int) -> String {
    return "\(age)"
}

func boo(age: Int, name: String) -> String {
    return "\(age) \(name)"
}

var fn3 = boo // 에러 발생
```

이런 경우에는 함수의 이름을 생략하지 않고 대입 구문을 작성해야 해요.

```swift
func boo(age: Int) -> String {
    return "\(age)"
}

func boo(age: Int, name: String) -> String {
    return "\(age) \(name)"
}

var fn3: (Int) -> String = boo
var fn4 = boo(age:name:)
```

타입 어노테이션과 함수 이름의 조합으로 대입 구문을구성하면 안 되는 경우도 있어요. 동일한 함수 타입을 사용하지만 매개변수명이 서로 다른 함수의 경우가 이에 해당해요.

```swift
func boo(age: Int, name: String) -> String {
    return "\(age) \(name)"
}

func boo(height: Int, nick: String) -> String {
    return "\(height) \(nick)"
}

var fn5: (Int, String) -> String = boo // 에러 발생
```

이런 경우에는 함수의 이름이 아니라 식별자를 사용해서 다음과 같이 정확하게 구분해 주어야 해요.

> let fn03: (Int, String) -> String = boo(age:name:)

함수 타입을 표시할 때 반환값이 없는 경우에는 빈 괄호 대신 Void를 사용해요. Void는 빈 튜플을 나타내는 값으로, 타입 알리어스로 정의된 단어에요. 클래스나 구조체 등의 객체가 아닌 키워드임에 주의해야 해요.

> public typealias Void = ()

위 코드가 Void 키워드를 선언하는 스위프트 내부 코드에요. typealias 키워드와 함께 선언된 Void에 빈 튜플을 대입하고 있죠.

### 일급함수의 특성 - 함수의 반환 타입으로 함수를 사용할 수 있음

일급 함수의 특성 중에서 두 번째로 학습할 부분은 함수의 반환 타입으로 함수를 사용할 수 있다는 특성이에요.

```swift
func desc() -> String {
    return "this is desc()"
}

func pass() -> () -> String {
    return desc
}

let p = pass()
p() // this is desc()
```

pass() 함수는 반환 타입으로 () -> String 타입의 함수를 사용하고 있어요. 이렇게 함수의 반환 타입으로 함수를 사용할 수 있어요. 이때 반환되는 함수는 () -> String 타입의 함수를 반환하고 있어요.

pass() 함수를 호출하면 desc() 함수가 반환되고, desc() 함수를 호출하면 "this is desc()" 문자열이 반환돼요.

함수의 반환값이 함수일 경우, 아무래도 함수의 형식이 복잡해질 가능성이 커요. 가독성도 매우 떨어지죠. 이를 방지하기 위해 최근의 문법에서는 반드시 인자값 부분에 괄호를 통해 감싸주도록 강제하지만, 그래도 가독성이 떨어지는 것은 사실이에요.

### 일급 함수의 특성 - 함수의 인자값으로 함수를 사용할 수 있음

함수를 인자값으로 전달할 때 그 함수는 하나의 타입이 돼요. 따라서 함수를 입력받는 인자값은 함수 타입으로 선언돼야 해요. 다음은 함수를 인자값으로 전달하는 예제에요.

```swift
func incr(param: Int) -> Int {
    return param + 1
}

func broker(base: Int, function fn: (Int) -> Int) -> Int {
    return fn(base)
}

broker(base: 3, function: incr) // 4
```

incr(param:) 함수는 Int 타입의 인자값을 받아서 Int 타입의 값을 반환하는 함수에요. 뒤이어 정의된 broker(base:function:)은 인자로 받은 함수를 실행하는 함수죠. 이 함수는 두 번째 매개변수에 대한 인자값에 어떤 함수가 들어오는지 상관하지 않아요. 단지 정수를 입력 받고 정수를 반환하는 함수이기만 하면 돼요.

그러니 broker(base:function:) 함수의 정의 구문만으로는 어떤 연산이 실행될지 짐작하기 어려워요. 실질적인 연산은 인자값으로 받는 함수에 달려 있기 때문이에요. 보통 이런 식으로 중개 역할을 하는 함수를 **브로커(Broker)** 라고 해요.

이번에는 콜백 함수를 사용하는 예를 살펴봐요.

```swift
func successThrough() {
    print("연산 처리가 성공했습니다.")
}

func failThrough() {
    print("처리 과정에서 오류가 발생했습니다.")
}

func divide(base: Int, success sCallBack: () -> Void, fail fCallBack: () -> Void) -> Int {
    guard base != 0 else {
        fCallBack()
        return 0
    }

    defer {
        sCallBack()
    }

    return 100 / base
}

divide(base: 30, success: successThrough, fail: failThrough) // 연산 처리가 성공했습니다.

divide(base: 0, success: successThrough, fail: failThrough) // 처리 과정에서 오류가 발생했습니다.
```

divide(base:success:fail:) 함수는 세 개의 인자값을 받아요. 첫 번째 인자값은 나누기 연산을 할 때 사용할 정수이고, 두 번째 인자값은 나누기 연산이 성공했을 때 실행할 함수이고, 세 번째 인자값은 나누기 연산이 실패했을 때 실행할 함수에요.

이런 식의 구문을 작성하면 함수가 성공, 또는 실패했을 때의 처리 과정을 외부에서 제어할 수 있어요. 즉, 함수의 내부 코드를 수정하지 않고도 외부에서 함수 내부의 실행 과정에 간섭할 수 있다는 뜻이에요.

defer 블록은 함수나 메소드에서 코드의 흐름과 상관없이 가장 마지막에 실행되는 블록이에요. 지연 블록이라고 부르기도 하는 이 블록에 작성된 구문은 작성된 위치에 상관없이 항상 함수의 종료 직전에 실행되기 때문에, 종료 시점에 맞추어 처리해야 할 구문이 있다면 우리는 어디에 작성해야 할지 고민하지 않고 defer 블록에 작성하면 돼요. defer 블록은 다음과 같은 특성을 가지고 있어요.

1. defer 블록은 작성된 위치와 순서에 상관 없이 함수가 종료되기 직전에 실행된다.
2. defer 블록을 읽기 전에 함수의 실행이 종료될 경우 defer 블록은 실행되지 않는다.
3. 하나의 함수나 메소드 내에서 defer 블록을 여러 번 사용할 수 있다. 이때에는 가장 마지막에 작성된 defer 블록부터 역순으로 실행된다.
4. defer 블록을 중첩해서 사용할 수 있다. 이때에는 바깥쪽 defer 블록부터 실행되며 안쪽에 있는 defer 블록은 가장 마지막에 실행된다.

위 함수가 성공/실패 함수를 인자값으로 받지 않는다고 가정하고, 만약 이 함수의 연산을 두 군대에서 호출해야 하는데 호출하는 지점마다 함수의 연산 성공/실패 시 처리해야 하는 내용이 다르다면 어떻게 해야 할까요? 아마도 그때마다 함수를 새로 작성해야 할 거에요. 하지만 위 예제처럼 함수의 성공/실패 시 처리해야 하는 내용을 외부에서 제어할 수 있다면 함수를 재작성하지 않고도 함수의 성공/실패 시 처리해야 하는 내용을 외부에서 제어할 수 있어요.

그런데 인자값으로 사용하기 위해 매번 새로운 성공/실패 함수를 작성해야 하는 것도 번거로운 작업 이에요.

이런 문제를 해결하고자 많은 함수형 언어에서는 익명 함수를 지원해요. 스위프트에서도 익명 함수를 지원하는데 이를 **클로저(Closure)** 라고 부르죠.

```swift
divide(base: 30, success: {
    () -> Void in
    print("연산 처리가 성공했습니다.")
}, fail: {
    () -> Void in
    print("처리 과정에서 오류가 발생했습니다.")
})
```

지금까지 우리는 함수를 인자로 넘기는 방법에 대해 학습했어요. 함수 내부의 코드를 외부에서 간섭할 수 있다는 점은 분명 큰 장접이에요. 하지만 이 장점은 함수 자체를 넘기지는 못해도 다른 방법을 함수를 전달하는 방법들을 제공하는 다른 언어들을 생각해본다면 장점이 되기엔 부족해보여요. 함수 자체를 인자로 넘길 수 있다는 특성은 어떤 장점이 있을까요?

함수 자체를 넘길 수 있는 일급 함수의 특성을 갖추고 있다면 직접 함수나 메소드의 객체를 전달할 수 있어요. 메소드를 검색하는 과정이 불필요하죠. 또한, 함수를 주고받을 수 있으므로 기존 함수를 데코레이션하는 문법을 구현할 수도 있어요.

[이전](https://github.com/MojitoBar/iOS-DeepDive/blob/main/%EA%BC%BC%EA%BC%BC%ED%95%9C_%EC%9E%AC%EC%9D%80%EC%94%A8%EC%9D%98_Swift_%EB%AC%B8%EB%B2%95%ED%8E%B8/7.3.md)
[다음](https://github.com/MojitoBar/iOS-DeepDive/blob/main/%EA%BC%BC%EA%BC%BC%ED%95%9C_%EC%9E%AC%EC%9D%80%EC%94%A8%EC%9D%98_Swift_%EB%AC%B8%EB%B2%95%ED%8E%B8/7.3.2.md)

[처음으로](https://github.com/MojitoBar/iOS-DeepDive/blob/main/%EA%BC%BC%EA%BC%BC%ED%95%9C_%EC%9E%AC%EC%9D%80%EC%94%A8%EC%9D%98_Swift_%EB%AC%B8%EB%B2%95%ED%8E%B8/README.md)
