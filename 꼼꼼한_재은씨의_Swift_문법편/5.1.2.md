# 배열의 동적 선언과 초기화

실제 프로그래밍 과정에서는 배열을 정의할 때 한꺼번에 필요한 아이템을 몽땅 집어넣고 정적 배열을 선언하는 경우는 거의 없어요. 대부분의 경우 배열을 동적으로 선언하고, 그 안에 필요한 아이템을 추가하거나 삭제하는 방식으로 사용하죠.

이번에는 배열을 동적으로 정의하는 방법에 대해 알아봐요.

값을 할당하지 않은 빈 배열을 선언하고 초기화할 때는 두 가지 형식을 사용할 수 있어요.

```swift
Array <아이템 타입>()
```

스위프트에서 배열을 정의하는 객체는 Array라는 구조체로 구현돼 있어요. 그래서 배열을 정의할 때는 Array라는 구조체의 생성자를 호출해야 해요.

스위프트에서 배열을 정의할 때에는 반드시 저장할 아이템의 타입도 함께 명시해야 해요. 컴파일러는 이때 입력받은 아이템 타입을 이용하여 다른 데이터 타입이 입력되었을 경우 잘못 입력되었음을 판단할 뿐만 아니라, 배열 내부에서 저장할 아이템들을 참조할 때도 이 타입 정보를 사용해요.

이처럼 사용 시점에서 <> 기호를 사용하여 배열 내부에서 사용할 아이템 타입을 지정하는 문법을 **제네릭(Generic)**이라고 해요.

동적으로 배열을 정의할 때에는 선언과 초기화 과정이 차례로 필요해요.

선언(Declare)은 '이러이러한 배열을 만들 겁니다.' 라고 미리 알려주는 것이고, 초기화(Initialization)는 '이러이러한 배열을 만들었어요.' 라고 실제로 만드는 것이에요.

객체지향 프로그래밍에서 배열 구조체는 선언만 되었을 때에는 메모리 공간을 차지하지 않다가 초기화되면서 메모리 공간을 차지하게 돼요.

다음은 cities 배열을 선언하고 동시에 초기화하는 예제에요.

```swift
var cities = Array<String>()
```

위 예제에서는 Array<String>()라는 생성자를 호출하여 cities라는 이름의 배열을 선언하고 동시에 초기화하고 있어요. 이때 Array<String>()라는 생성자는 String 타입의 아이템을 저장할 수 있는 빈 배열을 생성하라는 의미에요.

만약 이 배열을 단순히 선언만 하려면 타입 어노테이션을 사용하여 다음과 같이 작성하면 돼요.

```swift
var cities: Array<String>
```

이렇게 선언된 배열은 초기화되지 않았으므로 아직 메모리 공간을 할당받지 않은 상태에요. 이 배열을 사용하려면 초기화 과정을 거쳐야 해요.

```swift
cities = Array()
```

> 초기화할 때 왜 Array<String>() 대신 Array()를 사용하나요?

선언이 완료된 cities 변수는 이미 타입 어노테이션을 통해서 배열의 저장 타입이 지정되어 있어요.

그래서 초기화 과정에서는 저장 타입을 다시 명시할 필요가 없어요.

지금까지 알아본 것처럼 스위프트에서 배열은 Array<아이템 타입>으로 정의해요. 이 방식은 다른 프로그래밍 언어와는 다소 형식에서 차이가 있어요.

일반적으로 프로그래밍 언어에서 배열을 선언할 때에는 자료형 뒤에 [] 기호를 붙이는 방법을 많이 사용하거든요.

스위프트도 처음 발표되었을 당시에 배열 선언 문법은 이와 같았어요. 하지만 몇 번의 업그레이드를 거친 후 발표된 스위프트 GM 버전에서는 String[]으로 선언하는 배열 문법이 제거되었어요.

대신 이와 유사한 형식으로 배열을 정의하는 구문을 제공키로 했어요. 이것이 스위프트에서 배열을 정의하는 두 번째 형식이에요.

```swift
[아이템 타입]()
```

이 형식은 Array<아이템 타입>() 형식과 완전히 동일한 기능을 수행해요. 다만 Array<아이템 타입>() 형식보다는 조금 더 간결한 형태로 배열을 정의할 수 있다는 장점이 있어요.

이 구문 역시 선언과 초기화를 분리할 수 있어요. 먼저 배열 변수를 선언할 때에는 다음과 같이 작성해요.

```swift
var cities: [String]
```

선언된 배열을 초기화할 때에는 다음 두 가지 형식을 사용할 수 있는데, 이때 두 형식이 의미하는 바는 전혀 다르므로 주의해야 해요.

```swift
cities = [String]()
cities = []
```

첫 번째 형식은 선언된 배열 그대로를 초기화하지만, 두 번째 형식은 빈 배열 하나를 새로 만들어 이것을 변수에 할당해요.

엄밀히 말해서 두 번째 방식은 초기화가 아니에요. 따라서 초기화 연산자인 ()가 붙지 않을뿐더러 초기화 연산자 ()를 붙이면 오히려 오류가 발생해요.

[이전](https://github.com/MojitoBar/iOS-DeepDive/blob/main/%EA%BC%BC%EA%BC%BC%ED%95%9C_%EC%9E%AC%EC%9D%80%EC%94%A8%EC%9D%98_Swift_%EB%AC%B8%EB%B2%95%ED%8E%B8/5.1.1.md)
[다음](https://github.com/MojitoBar/iOS-DeepDive/blob/main/%EA%BC%BC%EA%BC%BC%ED%95%9C_%EC%9E%AC%EC%9D%80%EC%94%A8%EC%9D%98_Swift_%EB%AC%B8%EB%B2%95%ED%8E%B8/5.1.3.md)

[처음으로](https://github.com/MojitoBar/iOS-DeepDive/blob/main/%EA%BC%BC%EA%BC%BC%ED%95%9C_%EC%9E%AC%EC%9D%80%EC%94%A8%EC%9D%98_Swift_%EB%AC%B8%EB%B2%95%ED%8E%B8/README.md)
